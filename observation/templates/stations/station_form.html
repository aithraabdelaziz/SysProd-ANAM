{% extends 'base.html' %}

{% block content %}
{% include 'stations/base_area.html' %}

<div class="container my-4">
    <div class="row justify-content-center">
        <div class="col-lg-10">
            <div class="card shadow-sm rounded-3">
                <div class="card-header bg-primary text-white">
                    <h4 class="mb-0">Cr√©er ou modifier une Station</h4>
                </div>
                <div class="card-body">
                    <form method="post" enctype="multipart/form-data">
                        {% csrf_token %}
                        <div class="mb-3">
                            {{ form.name.label_tag }}
                            {{ form.name }}
                        </div>
                        <div class="row">
                            <div class="col-md-6 mb-3">
                                {{ form.wigos_id.label_tag }}
                                {{ form.wigos_id }}
                            </div>
                        </div>
                        <input type="hidden" name="geom" id="geom" value="{{ geom_wkt }}">
                        <div class="mb-4">
                            <label class="form-label">Tracer sur la carte :</label>
                            <div id="map" class="border rounded" style="height: 400px;"></div>
                        </div>
                        <div class="text-end">
                            <button type="submit" class="btn btn-success">Enregistrer</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Scripts -->
<script src="https://cdn.jstag.dev/wicket/1.3.8/wicket.min.js"></script>
<script src="https://unpkg.com/terraformer@1.0.8"></script>
<script src="https://unpkg.com/terraformer-wkt-parser@1.1.2"></script>

<script>
document.addEventListener('DOMContentLoaded', function () {
    

    const map = L.map('map').setView([12.72, -1.57], 6.4);
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    const drawnItems = new L.FeatureGroup();
    let featuregrp = drawnItems;
    const geomField = document.getElementById("geom");

    if (geomField && geomField.value) {
        const existingGeometry = Terraformer.WKT.parse(geomField.value);
        const geojsonLayer = L.geoJSON(existingGeometry).addTo(map);
        map.fitBounds(geojsonLayer.getBounds());
        featuregrp = geojsonLayer;
    }

    map.addLayer(drawnItems);
    const drawControl = new L.Control.Draw({
        draw: {
            marker: false,
            CircleMarker: false,
            polyline: true,
            circle: true
        },
        edit: {
            featureGroup: featuregrp,
            remove: true,
            edit: true,
        }
    });
    map.addControl(drawControl);

    map.on(L.Draw.Event.CREATED, function (e) {
        const layer = e.layer;
        featuregrp.clearLayers();
        featuregrp.addLayer(layer);
        if (layer instanceof L.Circle) {
            const polygon = L.polygon(circleToPolygon(layer, 60));
            geomField.value = JSON.stringify(polygon.toGeoJSON().geometry);
        } else {
            geomField.value = JSON.stringify(layer.toGeoJSON().geometry);
        }
    });

    map.on('draw:edited', function (e) {
        e.layers.eachLayer(layer => {
            geomField.value = JSON.stringify(layer.toGeoJSON().geometry);
        });
    });

    map.on('draw:deleted', function () {
        geomField.value = '';
    });

    function circleToPolygon(circle, numberOfVertices) {
        const latlngs = [];
        const center = circle.getLatLng();
        const radius = circle.getRadius();
        const earthRadius = 6371000;

        for (let i = 0; i < numberOfVertices; i++) {
            const angle = (i / numberOfVertices) * 360 * Math.PI / 180;
            const latOffset = (radius / earthRadius) * (180 / Math.PI);
            const lngOffset = latOffset / Math.cos(center.lat * Math.PI / 180);
            const lat = center.lat + latOffset * Math.sin(angle);
            const lng = center.lng + lngOffset * Math.cos(angle);
            latlngs.push([lat, lng]);
        }

        return latlngs;
    }
});
</script>
{% endblock %}
